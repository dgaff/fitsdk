#region Copyright
////////////////////////////////////////////////////////////////////////////////
// The following FIT Protocol software provided may be used with FIT protocol
// devices only and remains the copyrighted property of Dynastream Innovations Inc.
// The software is being provided on an "as-is" basis and as an accommodation,
// and therefore all warranties, representations, or guarantees of any kind
// (whether express, implied or statutory) including, without limitation,
// warranties of merchantability, non-infringement, or fitness for a particular
// purpose, are specifically disclaimed.
//
// Copyright 2015 Dynastream Innovations Inc.
////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 16.00Release
// Tag = development-akw-16.00.00-0
////////////////////////////////////////////////////////////////////////////////

#endregion


namespace Dynastream.Fit
{  
   public class Fit
   {        
      public const byte ProtocolVersion = ((ProtocolMajorVersion << ProtocolVersionMajorShift) + ProtocolMinorVersion);      
      public const byte ProtocolMajorVersion = 1;
      public const byte ProtocolMinorVersion = 0;      
      public const byte ProtocolVersionMajorShift = 4;
      public const byte ProtocolVersionMajorMask = (0x0F << ProtocolVersionMajorShift);

      public const ushort ProfileVersion = ((ProfileMajorVersion * 100) + ProfileMinorVersion);
      public const ushort ProfileMajorVersion = 16;
      public const ushort ProfileMinorVersion = 0;

      public const byte HeaderTypeMask = 0xF0; 
      public const byte CompressedHeaderMask = 0x80;      
      public const byte CompressedTimeMask = 0x1F;
      public const byte CompressedLocalMesgNumMask = 0x60;
      
      public const byte MesgDefinitionMask = 0x40;
      public const byte MesgHeaderMask = 0x00;      
      public const byte LocalMesgNumMask = 0x0F;
      public const byte MaxLocalMesgs = LocalMesgNumMask+1;

      public const byte MesgDefinitionReserved = 0x00;
      public const byte LittleEndian = 0x00;
      public const byte BigEndian = 0x01;

      public const byte MaxMesgSize = 255;
      public const byte MaxFieldSize = 255;

      public const byte HeaderWithCRCSize = 14;      
      public const byte HeaderWithoutCRCSize = (HeaderWithCRCSize - 2);

      public const byte FieldNumInvalid = 255;
      public const byte FieldNumTimeStamp = 253;
            
      public const ushort SubfieldIndexMainField = SubfieldIndexActiveSubfield + 1;
      public const ushort SubfieldIndexActiveSubfield = 0xFFFE; 
      public const string SubfieldNameMainField = "";

      public static FitType[] BaseType = new FitType[] 
      {
         new FitType(false, 0x00, "enum", (byte)0xFF, 1, false, false),
         new FitType(false, 0x01, "sint8", (sbyte)0x7F, 1, true, true),
         new FitType(false, 0x02, "uint8", (byte)0xFF, 1, false, true),
         new FitType(true, 0x83, "sint16", (short)0x7FFF, 2, true, true),
         new FitType(true, 0x84, "uint16", (ushort)0xFFFF, 2, false, true),
         new FitType(true, 0x85, "sint32", (int)0x7FFFFFFF, 4, true, true),
         new FitType(true, 0x86, "uint32", (uint)0xFFFFFFFF, 4, false, true),
         new FitType(false, 0x07, "string", (byte)0x00, 1, false, false),
         new FitType(true, 0x88, "float32", (float)0xFFFFFFFF, 4, true, false),
         new FitType(true, 0x89, "float64", (double)0xFFFFFFFFFFFFFFFF, 8, true, false),
         new FitType(false, 0x0A, "uint8z", (byte)0x00, 1, false, true),
         new FitType(true, 0x8B, "uint16z", (ushort)0x0000, 2, false, true),
         new FitType(true, 0x8C, "uint32z", (uint)0x00000000, 4, false, true),
         new FitType(false, 0x0D, "byte", (byte)0xFF, 1, false, false)
      };      
          
      
      public struct FitType
      {
         public bool endianAbility; 
         public byte baseTypeField;  
         public string typeName;         
         public object invalidValue; 
         public byte size;
         public bool isSigned;       
         public bool isInteger;       

         public FitType(bool endianAbility, byte baseTypeField, string typeName, object invalidValue, byte size, bool isSigned, bool isInt)
         {
            this.endianAbility = endianAbility;
            this.baseTypeField = baseTypeField;
            this.typeName = typeName;
            this.invalidValue = invalidValue;
            this.size = size;
            this.isSigned = isSigned;
            this.isInteger = isInt;
         }
      }

      // Index into the BaseTypes array
      public const byte Enum = 0x00;
      public const byte SInt8 = 0x01;
      public const byte UInt8 = 0x02;
      public const byte SInt16 = 0x03;
      public const byte UInt16 = 0x04;
      public const byte SInt32 = 0x05;
      public const byte UInt32 = 0x06;
      public const byte String = 0x07;
      public const byte Float32 = 0x08;
      public const byte Float64 = 0x09;
      public const byte UInt8z = 0x0A;
      public const byte UInt16z = 0x0B;
      public const byte UInt32z = 0x0C;
      public const byte Byte = 0x0D;
     
      // And this with the type defn to get the index
      public const byte BaseTypeNumMask = 0x1F;      
   }
}